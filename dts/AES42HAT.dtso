/*
 * Device Tree Overlay for a custom Raspberry Pi setup.
 *
 * This template demonstrates how to:
 * 1. Define custom pin configurations (pinctrl).
 * 2. Enable and map peripherals (I2C, UART, I2S) to these custom pins.
 * 3. Define GPIO pins and associated interrupts.
 *
 * NOTE: Replace all BCM pin numbers (like 17, 27, 22, etc.) and statuses
 * with your specific hardware requirements.
 */
/dts-v1/;
/plugin/;

/ {
	compatible = "brcm,bcm2835", "brcm,bcm2836", "brcm,bcm2837", "brcm,bcm2711"; // Add "brcm,bcm2712" for Pi 5

	fragment@0 {
		target = <&gpio>;
		__overlay__ {
			pinctrl-names = "default";
			pinctrl-0 = <&pcfg_main>;

			pcfg_main: pcfg_main_pins {
				// Standard I2C for EEPROM
				brcm,pins = <0 1>;
				brcm,function = <BCM2835_FSEL_ALT0>; // I2C0
				brcm,pull = <BCM2835_PUD_UP>; // I2C pins require pull-ups

				// Additional I2C
				brcm,pins = <2 3>;
				brcm,function = <BCM2835_FSEL_ALT0>; // I2C1 (typically)
				brcm,pull = <BCM2835_PUD_UP>;

				// Clock Inputs
				brcm,pins = <4 6>;
				brcm,function = <BCM2835_FSEL_INPUT>; // Set as input
				brcm,pull = <BCM2835_PUD_OFF>;

				// GPIO Output (Active Low, Pull-up)
				brcm,pins = <5>;
				brcm,function = <BCM2835_FSEL_OUTP>;
				brcm,pull = <BCM2835_PUD_UP>;

				// GPIO Bidirectional (Interrupt Input Low Active)
				brcm,pins = <7>;
				brcm,function = <BCM2835_FSEL_INPUT>;
				brcm,pull = <BCM2835_PUD_UP>; // Pull-up for low-active interrupt

				// Unused Pins (Pull-up)
				brcm,pins = <8>;
				brcm,function = <BCM2835_FSEL_INPUT>;
				brcm,pull = <BCM2835_PUD_UP>;

				// Unused Pins (Floating/Input)
				brcm,pins = <9 10 11 13 16 17>;
				brcm,function = <BCM2835_FSEL_INPUT>;
				brcm,pull = <BCM2835_PUD_OFF>;

				// GPIO Output (Pull-down)
				brcm,pins = <12>;
				brcm,function = <BCM2835_FSEL_OUTP>;
				brcm,pull = <BCM2835_PUD_DOWN>;

				// UART (TXD/RXD)
				brcm,pins = <14 15>;
				brcm,function = <BCM2835_FSEL_ALT5>; // UART0/PL011 (typically)
				brcm,pull = <BCM2835_PUD_OFF>;

				// I2S (Stereo Audio Interface)
				brcm,pins = <18 19 20 21>;
				brcm,function = <BCM2835_FSEL_ALT0>; // PCM/I2S function (typically)
				brcm,pull = <BCM2835_PUD_OFF>;

				// PCM Input/Output 1-3 (Pi 5 specific - assuming PCM function)
				brcm,pins = <22 23 24 25 26 27>;
				brcm,function = <BCM2835_FSEL_ALT0>; // Assuming same ALT function as 18-21
				brcm,pull = <BCM2835_PUD_OFF>;
			};
		};
	};

	// --- FRAGMENT 1: ENABLE AND CONFIGURE PERIPHERALS ---

	// I2C 1 (typically the main bus)
	fragment@1 {
		target = <&i2c1>;
		__overlay__ {
			pinctrl-names = "default";
			pinctrl-0 = <&pcfg_main>;
			status = "okay";

			// You can define I2C devices here if known:
			// example_sensor@42 {
			// 	compatible = "vendor,sensor-name";
			// 	reg = <0x42>;
			// };
		};
	};

	// UART 0 (PL011, usually used for console/Bluetooth on Pi 3/4)
	fragment@2 {
		target = <&uart0>;
		__overlay__ {
			pinctrl-names = "default";
			pinctrl-0 = <&pcfg_main>;
			status = "okay";
		};
	};

	// I2S interface
	fragment@3 {
		target = <&i2s>;
		__overlay__ {
			pinctrl-names = "default";
			pinctrl-0 = <&pcfg_main>;
			status = "okay";
		};
	};

	// --- FRAGMENT 4: DEFINING GPIO INTERRUPT PINS ---
	// Define any GPIO pins that require special handling or interrupt binding.
	fragment@4 {
		target = <&gpio>;
		__overlay__ {
			interrupt_pin {
				gpios = <17 0>; // BCM 17, GPIO_ACTIVE_HIGH (0 for active-low)
				label = "my_interrupt_source";
				// Define custom properties needed by the driver here
			};
		};
	};
};
