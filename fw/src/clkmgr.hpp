/** @file
 * AES42HAT clock management.
 * 
 * @addtogroup AES42HAT_clk
 * @ingroup AES42HAT
 * @{
 */

#pragma once

#include "handler.hpp"
#include "nvic_drv.hpp"
#include <array>
#include <cstddef>
#include <cstdint>

namespace lpc865 {
    class Ftm;
    class Pint;
}

class Channel;

/** Clock Manager.
 *
 * The clock manager gets periodically called for each transmit block, so it
 * works synchronous with the audio clock on the transmit side, which is also
 * the Raspberry Pi side audio clock. The interrupt source is the counter
 * overflow of FTM0.
 *
 * FTM0 is clocked from the bit clock, which operates at 64x wordclock.
 * Therefore a complete block of 192 samples takes 192 * 64 = 12288 clocks. The
 * BLS signal is generated at the beginning, with the rising edge at the point
 * when the counter resets to 0, and the falling edge 64 clocks later. This
 * creates a pulse that is one wordclock period long.
 *
 * The problem is that the exact position of this pulse within the wordclock
 * period isn't initially known, so in order to obtain exact phase
 * relationships, we first need to adjust this position. For that we capture the
 * block start pulse generated by the SRC4392 chips in FTM0 channels 2..5.
 *
 * The most straightforward method is to capture the transmitter's block start
 * signal of each SRC4392. We operate the BLS pin in input mode, so we can't use
 * that. But the block start signal can also be routed to the SRC4392's
 * interrupt pin, by using the TSLIP interrupt source, and setting the BSSL bit
 * to attach it to the block start condition.
 *
 * With this arrangement, the leading edge of the interrupt signal occurs at
 * some point during the BLS pulse, and the position should be the same for all
 * SRC4392 chips. The aim is to place it in the middle of the pulse. To achieve
 * this, we tweak the counter period to shift the generated BLS signal so that
 * its center coincides with the interrupt. Adjusting the counter period is done
 * with the counter modulus. If the interrupt occurs too late in the BLS pulse,
 * the modulus must be increased, and if it occurs too early it must be
 * decreased. Once the right position is obtained, the modulus is set to its
 * nominal value and left there.
 */
class Clkmgr : public Handler, public arm::Interrupt {
public:
    void act() override;

    void isr() override;

    Clkmgr(lpc865::Ftm &ftm, lpc865::Pint &pint, Channel *channels, uint8_t tch, uint8_t irq);

private:
    uint8_t tch_;
    uint8_t irq_;
    lpc865::Ftm &ftm_;
    lpc865::Pint &pint_;
    Channel *channels_;
};

//!@}
