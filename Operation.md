# Notes on the operation of the circuit

This document goes into the operation of the circuit and the firmware in some
more detail. It complements the firmware source code, and should help
understanding where the source code isn't making itself clear enough.

## General control processor operation

The control processor is mainly used for configuring the transceiver chips, and
for handling the channel status and user bits of the AES3 / AES42 signals. This
is important since AES42 makes full use of those bits, and it greatly helps a
host processor when this side-band information handling is offloaded into a
specialized processor.

### Handling of C and U bits

The transceiver chips U10, U20, U30 and U40 have a double-buffered memory for
the entire C and U bit information for both receiver and transmitter side. The
buffers can be accessed through the SPI control port. The speed of the SPI port
is sufficient for keeping up with the data rate of 4 transceivers operating in
parallel in both directions (using the I2C bus mode instead wouldn't provide
enough speed). The control processor is intended to read the incoming data on
all channels once for every block of 192 samples. Optionally, it should also be
able to write the outgoing data for all 4 channels for every block of 192
samples, too.

The transmitters are all synchronized to the same clock, therefore the data
blocks can be written in common. The trigger (interrupt) for writing new blocks
comes from the BLS signal. For each trigger, 192 * 8 * 2 bits = 3072 bits = 384
bytes must be written if all channels are to be covered. This is because there
are separate blocks of 192 bits for each of 8 subchannels' C and U bits.

The receivers are clocked individually, and each may operate at a different
frequency. Therefore the data transfer is triggered separately for each. With
each trigger, 768 bits = 96 bytes must be read. The trigger comes from the INT
signal of the respective transceiver, which must be programmed to fire once per
received block.

This means that 5 independent trigger sources compete for SPI bandwidth,
requiring arbitration. The worst case occurs at the highest sampling rates of
~200 kHz for both receivers and transmitters, which leads to a total net data
rate of 800 kByte/s, or 6.4 MBit/s. In practice, the clock rate of the SPI port
will therefore need to be 10 .. 30 MBit/s, which is within the capability of
both the control processor and the transceiver chips.

The SPI interface in the control processor supports DMA, which is useful in this
scenario, to relieve the CPU of handling the actual data transfer.

Note that all 5 trigger signals (BLS, INTA, INTB, INTC, INTD) are connected to
support time stamping with FTM0. This permits phase measurements (see below), as
well as frequency measurements. FTM0 has 6 channels, of which 5 are used for
this purpose.

### Transceiver configuration

The control processor configures the transceiver chips according to the desired
operation mode. This is determined by the host processor, which uses the I2C
interface to set the operation mode by writing control data to the control
processor. The control processor then configures the transceivers accordingly
via SPI0.

### Other functions

The control processor monitors the phantom voltage of all 4 channels using its
ADC (inputs ADC_0 .. ADC_3). It can report the values to the host via the I2C
interface. A significant deviation from the nominal values of 10V or 12V
indicates a hardware problem.

Host communication, microphone synchronization and remote control are described
below in their respective chapters.

### Control processor clock setup

Most of the functions of the control processor don't need to be synchronized
with the audio clock. An internal free running oscillator can clock the chip at
60 MHz, and generate most of the required clocks, including the CPU clock.

For additional flexibility, both MCLK and ACLK signals are routed to the control
processor where they can be used for further clocking related tasks. Either one
or the other can be used to supply the internal `external_clk` signal, which can
serve as the reference for a PLL to generate arbitrary frequencies.

## Mode 2 clock synchronization

When AES42 was developed, one of the problems to solve was how to synchronize
the microphone to a common wordclock, given that the audio signal runs in the
"wrong" direction from the microphone to the controller, where the synchronizing
wordclock needs to go the other way. The solution devised was to establish a
distributed PLL using the remote control facility, which allows low-speed
control signals to be sent by the controller to the microphone via a modulation
scheme of the phantom power. A periodic control word generated by the controller
transmits the phase error to the microphone, where it tunes the clock generator
to produce the correct frequency.

The modulation scheme requires the phantom power of nominally 10 V to be raised
to 12 V in pulses that contain the information. On the AES42HAT, this is done by
switching a boost switchmode regulator between 10 and 12 V, and shaping the
transitions with a pulse driver. This avoids the power dissipation losses of a
linear regulator that is commonly used for this function.

### Controlling pulse timing

The pulse timing is controlled by the control processor, taking advantage of its
FTM1 timer module in conjunction with firmware. In mode 2, the pulses needn't be
synchronous with the wordclock, so the only requirement is to produce the
correct pulse widths according to the AES42 specification. This allows the TIM1
to be clocked internally. FTM1 has 4 channels which are used to control the 4
AES42 channels, so communication can proceed on all channels simultaneously.
Each of the timer channels controls one MODx signal.

The basic idea is to program the TIM1 such that its counter produces one TOF
event per bit that is sent as the remote control signal. Each bit is represented
by a signal that is initially low, and changes to high during the bit period.
For a 0 bit the transition to high happens late during the bit period, while for
a 1 bit it happens early.  This can be generated by using the PWM capability of
the TIM1. During the bit period the counter counts up from its initial value in
CNTIN to its final value in MOD, thereby defining the time for an entire bit.
Somewhere in between, an output transition happens as a consequence of a compare
event. This is what is described as "Edge-Aligned PWM" in the reference manual
of the control processor.

It is possible to trigger a DMA channel on the reloading of the counter (see bit
INITTRIGEN), and have it rewrite the compare registers. This can be used to
reduce the interrupt load by precomputing a list of transition points and
placing it in memory. Alternatively, an interrupt can be generated and the
interrupt service routine takes care of setting the compare registers once for
each bit period.

Firmware bears the responsibility to convert the data to be sent into the
appropriate timing values to use by the TIM1 channel for each bit.

### Phase detection

The control processor implements the phase detection part of the distributed
PLL. It consists of comparing the phase of the incoming AES42 signal with the
local wordclock signal. One phase measurement is needed for each time a control
word is sent to the microphone, which is nominally 6 times per second. Therefore
it is acceptable, and even advantageous, to use the block start signal instead
of the wordclock, to take a phase measurement. This allows aligning the block
start in addition to the wordclock.

The action of the PLL is supposed to minimize the phase error by steering the
clock generator in the microphone. To achieve this, the measured phase error is
filtered and converted into a 13-bit data word which is sent to the microphone 6
times per second. The microphone uses the data word to set the frequency of the
clock generator within a narrow band centered around the nominal frequency.
Traditionally this was done by having a D/A converter control a voltage
controlled crystal oscillator. Other arrangements that produce a similar effect
are also possible, however.

The phase detection is done with the help of TIM0 in capture mode. Its channel 3
captures the edges of the BLS signal, which is the block start signal derived
from the local wordclock. This serves as the reference against which the phase
of the incoming signal from the microphones is measured. The 4 AES42 inputs use
channels 0, 1, 4 and 5 of TIM0, so their phases can be measured simultaneously.
The phase difference is the capture value of the microphone channel minus the
capture value of the reference channel.

The counter of TIM0 is free running, and clocked internally from a clock source
that is unrelated to the audio clocks. This effectively dithers the measurement
results and avoids systematic quantization errors. Additionally, since block
starts are much more frequent than control word transmissions, measurements can
be averaged or smoothed to increase resolution even further.

Implementing phase detection in this way depends on each transceiver chip (U10,
U20, U30, U40) generating an interrupt signal when there is a block start of the
incoming audio signal. This also signals that a complete block of channel status
and user bits has been received and should be fetched using the SPI interface,
so the interrupt signal should not merely cause a capture in TIM0, but the
interrupt service routine should also schedule the data transfer using the SPI
interface.

### Fast mode

The AES42 standard supports two different communication speeds for the remote
control signal, standard mode and fast mode, with support for the latter being
optional for both the microphone and the controller. The implementation
described above for the AES42HAT can support either, but all four channels must
operate in the same mode, because of the usage of a common timer for generating
the timing.

In practice, fast mode would therefore be useable only if all connected
microphones support it. It shouldn't be selected otherwise.

## Mode 3 clock synchronization

As mode 2 synchronization has some disadvantages, Schoeps devised an additional
mode 3 as a different way of remote controlling and synchronizing the
microphone. In mode 3, the synchronization doesn't use the remote control
facility, it is the other way around. The remote control commands get sent
using the synchronization signal as a carrier.

Synchronization is achieved by modulating a low level sinewave onto the phantom
power, with the wordclock frequency as the carrier frequency. On the microphone
side, a narrow band circuit can retrieve this carrier despite its low level. The
advantage is that the chance of interference with the audio signal in the
microphone is greatly reduced, as is the potential radiation from the cable.
Furthermore, it is not necessary to support remote control just for
synchronization. If synchronization is all that's needed, it suffices to just
send the carrier.

The controller needs to be able to generate a sinewave to be superimposed on the
phantom power, and the phase of this sinewave should be directly related to the
local wordclock. This is achieved by bandpass filtering the WCLK signal to
remove harmonics and approximate a sine wave.

The WCLK signal is always at the base frequency, even for double or quadruple
sampling rates, so in practice it is at 44.1 or 48 kHz. This means that there
must be a separate divider to generate it. This can be implemented with the help
of the PLL and the CLKOUT divider, but the SPI1 could also be employed in a
creative way to achieve this.

The remote control signal must be synchronous to the carrier, as each bit that
is sent modulates the amplitude of one full sine wave period. This is achieved
by clocking UART2 with the wordclock signal and using the UART transmit signal
as the modulating signal. Only one microphone can be talked to at any one time
in this way, but since synchronization in mode 3 does not depend on remote
control communication, this isn't a serious drawback.

## Console mode

As an extension to AES42, Schoeps has defined a console mode that uses the user
bit of the right subchannel for a console channel that transmits arbitrary data
in UART format for supporting a textual console connection with the microphone
that can be used during normal operation. Together with an extension of the
remote control command set, this allows bidirectional communication with the
microphone for arbitrary purposes, including an extended command set that
supports functionality beyond what AES42 provides.

Standard AES42 assumes that the user bit of both subchannels contains the same
data, and typically a controller receiving the signal would only look at the
left subchannel. Using the right subchannel therefore doesn't usually impair
normal operation, and the full information AES42 sends in the user bit is still
available.

Console mode is not normally necessary with multiple microphones concurrently.
Therefore the AES42HAT supports using console mode with one microphone at a
time. Multiple microphones can be in console mode concurrently, but only one can
send data at a time, as the AES42HAT can only communicate with one of them.

Towards the host processor, i.e. the Raspberry Pi, the console data is forwarded
from/to its UART interface on Hat pins 8&10, using UART0 of the control
processor. The I2C interface is used to select the microphone to communicate
with.

To support console mode, channel status and user bits must be treated separately
for each of the two subchannels. The AES42HAT is capable of doing this. Incoming
console data in the user bit of the right subchannel can be treated in two
different ways:

### Console mode through SPI0

Here, the data for both user bits and channel status bist for both subchannels
is read by the control processor via SPI0 once for each channel status block
(i.e. once every 192 samples). This is usually done anyway, hence no additional
communication is needed.

The data is decoded in software using the CPU, hence this method causes a
significant CPU load. The problem is mainly to find start bits, which can occur
anywhere in the U-bit stream, and extract the following 8 bits as a data byte.
This bit banging is CPU intensive.

### Console mode through UART1

By using GPO3 and GPO4 of each transceiver chip for the receiver wordclock and
the U-bit, respectively, a situation is created where UART1 can be directly used
to receive the signal in synchronous mode. This saves considerable CPU power by
using the UART hardware intelligently.

## Host communication

The host processor controls the operation of the AES42HAT, i.e. its control
processor, via I2C on pins 3&5 of the Hat connector. The control processor is
the target, and the host processor is the controller. This makes the AES42HAT
appear to the Host processor as a peripheral in much the same way as an audio
codec would be. Configuration is done by writing to registers, and status is
monitored via reading of registers, using the I2C protocol in the usual way.

When the AES42HAT requests the attention of the host processor, it pulls the
REQ/ISP signal low until the host processor services the request. The host
processor would typically react by reading a service request status word via
I2C, which allows it to identify the nature of the request, and service it
accordingly.

The UART interface between host and control processor on pins 8&10 of the Hat
connector is used for remote control of the microphone, and for console mode. It
can also be used for updating the control processor firmware.

### I2C communication

The I2C target of the control processor reacts to a range of I2C 7-bit addresses
like detailed in the following table:

| Addr | Function               |
|------|------------------------|
| 0x70 | U10 passthrough        |
| 0x71 | U20 passthrough        |
| 0x72 | U30 passthrough        |
| 0x73 | U40 passthrough        |
| 0x74 | board control          |
| 0x75 | service request status |

The passthrough mode allows the host to access the transceiver chips as if they
were connected directly to the I2C bus. This is intended to help driver software
that was written for a direct connection of the SRC4392 to the I2C bus. The
target addresses are chosen to be compatible with the I2C mode of the SRC4392.
The control processor arbitrates between its own accesses to the transceiver
chips, and those by the host processor.

### UART communication

The UART interface is used for microphone remote control and console mode. One
of the microphones is selected via I2C as the peer to communicate with. When no
microphone is selected, the UART interface can be used as a console interface
with the control processor, if desired.

A baud rate of 230400 bits/s is used with no parity and 1 stop bit. This is
faster than the microphone side, so the possibility exists that the host
overruns the buffering of the AES42HAT, which is handled by XON/XOFF signaling
by the control processor to the host. There is no need for that in the other
direction, as the host should always be quick enough to receive data.

The control processor translates data it receives from the host processor into
remote control pulses for the microphone, according to the selected remote
control and synchronization mode. It can buffer an entire line of at least 80
characters before overrunning.

The control processor forwards console data it receives from the microphone to
the host processor.
